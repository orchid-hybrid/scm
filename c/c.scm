(define (mangle s)
  (define (hyphen-down char)
    (if (equal? char #\-)
        #\_
        char))
  (list->string (map hyphen-down (string->list (symbol->string s)))))

(define (mangle* s n)
  (let ((m (mangle s)))
    (cond ((or (equal? s 'invoke-closure)
               (equal? s 'vector))
           (string-append "scm_" (string-append m (number->string n))))
          ((or (equal? s 'make-closure)
               (equal? s 'vector-ref))
           (string-append "scm_" m))
          (else m))))

(define (string-quote s)
  (string-append "\"" (string-append s "\"")))

(define (emit-call f args)
  (cond ((and (equal? f 'vector-ref)
              (= 2 (length args))
              (equal? (car args) 'env))
         (display "env[")
         (display (cadr args))
         (display "]"))
        (else
         (display (mangle* f (length args)))
         (display "(")
         (let ((n (length args)))
           (cond ((= n 0))
                 ((> n 0)
                  (emit-c (car args))
                  (for-each (lambda (arg)
                              (display ",")
                              (emit-c arg))
                            (cdr args)))))
         (display ")"))))

(define (prim? exp)
  (or (eq? exp '+)
      (eq? exp '-)
      (eq? exp '*)
      (eq? exp '=)
      (eq? exp 'print)
      (eq? exp 'newline)))

(define (rename-prim p)
  (cond
    ((eq? '+ p)       "__add")
    ((eq? '- p)       "__sub")
    ((eq? '* p)       "__mul")
    ((eq? '= p)       "__num_eq")
    ((eq? 'print p) "__print")
    ((eq? 'newline p) "__newline")
    (else             (error "unhandled primitive: " p))))

(define (emit-prim-prelude-prelude)
  (for-each
   (lambda (c) (display c) (newline))
   (list
    "scm __print;"
    "scm __newline;"
    "scm __add;"
    "scm __sub;"
    "scm __mul;"
    "scm __num_eq;")))

(define (emit-prim-prelude)
  (for-each
   (lambda (c) (display c) (newline))
   (list
    "__print = scm_wrap_prim(scm_print);" 
    "__newline = scm_wrap_prim(scm_newline);" 
    "__add = scm_wrap_prim(scm_add);"
    "__sub = scm_wrap_prim(scm_sub);" 
    "__mul = scm_wrap_prim(scm_mul);" 
    "__num_eq = scm_wrap_prim(scm_num_eq);")))

(define (emit-c term)
  (cond ((prim? term)
	 (display (rename-prim term)))
	((number? term)
         (display term))
        ((string? term)
         (display "scm_string")
         (display "(")
         (display (string-quote term))
         (display ")"))
        ((symbol? term)
         (display (mangle term)))
        ((list? term)
         (emit-call (car term) (cdr term)))
        (else (error term "emit-c!"))))


(define (test-c term)
  (let ((collector (make-collector)))
    (let* ((cc (perform-closure-conversion term))
           (main ((hoist (cdr collector)) cc))
           (definitions ((car collector))))
      (display "#include \"scm.h\"")
      (newline)
      (emit-prim-prelude-prelude)
      (newline)
      (newline)
      (for-each (lambda (definition)
                  ;;(define name (lambda (args) body))
                  (let ((name (cadr definition))
                        (args (cadr (caddr definition)))
                        (body (caddr (caddr definition))))
                    (display "scm ")
                    (display (mangle name))
                    (display "(")
                    (display "scm* env")
                    (for-each (lambda (arg)
                                (display ", ")
                                (display "scm ")
                                (display (mangle arg)))
                              (cdr args))
                    (display ") {")
                    (newline)
                    (display "  return ")
                    (emit-c body)
                    (display ";")
                    (newline)
                    (display "}")
                    (newline)
                    (newline)))
                definitions)
      (display "void main() {")
      (newline)
      (emit-prim-prelude)
      (newline)
      (display "  ")
      (emit-c main)
      (display ";")
      (newline)
      (display "}")
      (newline))))
